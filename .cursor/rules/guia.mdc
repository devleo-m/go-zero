---
alwaysApply: true
---

üìã ROADMAP COMPLETO AT√â O MVP (Dividido em Etapas)
ETAPA 1: FUNDA√á√ÉO E ESTRUTURA üèóÔ∏è
Objetivo: Entender e criar a estrutura base do projeto
Status: üëà ESTAMOS AQUI
1.1. Entender Arquitetura Hexagonal (Conversa)

O que √© e por que usar?
Camadas: Domain ‚Üí UseCase ‚Üí Adapters
Fluxo de dados

1.2. Criar Estrutura de Pastas (Pr√°tica)

Criar pastas vazias
Entender onde cada coisa vai
Criar README.md explicativo em cada pasta

1.3. Configurar Go Modules (Pr√°tica)

Inicializar projeto com go mod init
Entender go.mod e go.sum
Adicionar depend√™ncias b√°sicas


ETAPA 2: AMBIENTE DE DESENVOLVIMENTO üê≥
Objetivo: Ter tudo rodando localmente
2.1. Docker Basics (Conversa)

O que √© Docker?
Por que usar?
Conceitos: Container, Image, Volume

2.2. PostgreSQL com Docker (Pr√°tica)

Criar docker-compose.yml
Subir Postgres
Conectar com cliente (DBeaver/pgAdmin)

2.3. Redis com Docker (Pr√°tica)

Adicionar Redis ao docker-compose
Testar conex√£o

2.4. Hot Reload (Air) (Pr√°tica)

Instalar Air
Configurar .air.toml
Testar reload autom√°tico


ETAPA 3: CONFIGURA√á√ïES E INFRAESTRUTURA ‚öôÔ∏è
Objetivo: Sistema de configs e logs profissional
3.1. Vari√°veis de Ambiente (Pr√°tica)

Criar .env
Usar godotenv
Boas pr√°ticas de seguran√ßa

3.2. Sistema de Logs (Pr√°tica)

Implementar Zap Logger
N√≠veis de log (Debug, Info, Error)
Logs estruturados

3.3. Valida√ß√£o de Configs (Pr√°tica)

Validar configs na inicializa√ß√£o
Mensagens de erro claras


ETAPA 4: DATABASE - MIGRATIONS üóÑÔ∏è
Objetivo: Controlar vers√µes do banco
4.1. O que s√£o Migrations? (Conversa)

Por que usar?
Up/Down migrations
Versionamento

4.2. Golang-Migrate (Pr√°tica)

Instalar ferramenta
Criar primeira migration (users)
Executar up/down

4.3. Makefile para Migrations (Pr√°tica)

Comandos: migrate-up, migrate-down
Automatizar processo


ETAPA 5: DOMAIN LAYER (Entidades) üß†
Objetivo: Criar as regras de neg√≥cio puras
5.1. Domain-Driven Design B√°sico (Conversa)

Entidade vs Value Object
Agregados
Repository Pattern

5.2. User Entity (Pr√°tica)

Criar struct User
M√©todos de neg√≥cio
Valida√ß√µes

5.3. Value Objects (Pr√°tica)

Email
Phone
Password

5.4. Domain Errors (Pr√°tica)

Erros customizados
Wrapping de erros


ETAPA 6: GORM - MODELS E REPOSITORIES üíæ
Objetivo: Persist√™ncia de dados
6.1. GORM Basics (Conversa)

ORM vs SQL puro
Como GORM funciona
Hooks e Callbacks

6.2. User Model (GORM) (Pr√°tica)

Criar struct com tags GORM
Convers√£o Domain ‚Üî Model
Hooks (BeforeCreate, BeforeUpdate)

6.3. User Repository (Pr√°tica)

Implementar interface
CRUD completo
Queries complexas

6.4. Testes de Repository (Pr√°tica)

Setup de teste
Fixtures
Assertions


ETAPA 7: USE CASES (Regras de Aplica√ß√£o) üéØ
Objetivo: Orquestrar l√≥gica de neg√≥cio
7.1. Use Case Pattern (Conversa)

Diferen√ßa entre Domain e UseCase
Input/Output DTOs
Orquestra√ß√£o

7.2. Create User Use Case (Pr√°tica)

Validar input
Chamar repository
Retornar output

7.3. Authenticate User Use Case (Pr√°tica)

Verificar senha
Gerar JWT
Registrar login

7.4. Testes de Use Case (Pr√°tica)

Mocks de repository
Testes unit√°rios


ETAPA 8: HTTP LAYER (API REST) üåê
Objetivo: Expor endpoints HTTP
8.1. Gin Framework (Conversa)

Por que Gin?
Routing
Middlewares

8.2. Request/Response DTOs (Pr√°tica)

Structs de request
Structs de response
Valida√ß√£o (validator)

8.3. User Handler (Pr√°tica)

POST /users (criar)
POST /auth/login
GET /users/:id

8.4. Middlewares (Pr√°tica)

Logger
Recovery (panic handler)
CORS
Auth (JWT)


ETAPA 9: AUTENTICA√á√ÉO JWT üîê
Objetivo: Seguran√ßa da API
9.1. JWT Basics (Conversa)

Como funciona?
Claims
Expira√ß√£o

9.2. Gera√ß√£o de Token (Pr√°tica)

Criar token ao login
Refresh token

9.3. Valida√ß√£o de Token (Pr√°tica)

Middleware de auth
Extrair user do token


ETAPA 10: MULTI-TENANT (Schema por Tenant) üè¢
Objetivo: Isolamento de dados
10.1. Multi-Tenant Strategies (Conversa)

Schema separado vs shared schema
Trade-offs

10.2. Tenant Manager (Pr√°tica)

Criar schema dinamicamente
Switch de schema por request

10.3. Tenant Middleware (Pr√°tica)

Detectar tenant do request
Injetar no contexto


ETAPA 11: M√ìDULO PATIENT üë•
Objetivo: Primeiro m√≥dulo tenant-specific
11.1. Patient Entity (Pr√°tica)

Domain layer completo

11.2. Patient Repository (Pr√°tica)

CRUD em schema tenant

11.3. Patient Use Cases (Pr√°tica)

Create, List, Update

11.4. Patient Handler (Pr√°tica)

Endpoints REST


ETAPA 12: M√ìDULO APPOINTMENT üìÖ
Objetivo: Agendamento de consultas
12.1. Appointment Entity (Pr√°tica)
12.2. Appointment Repository (Pr√°tica)
12.3. Appointment Use Cases (Pr√°tica)
12.4. Appointment Handler (Pr√°tica)

ETAPA 13: TESTES E2E üß™
Objetivo: Testar fluxo completo
13.1. Setup de Testes E2E (Pr√°tica)

Banco de teste
Fixtures

13.2. Cen√°rios de Teste (Pr√°tica)

Criar user ‚Üí Login ‚Üí Criar patient ‚Üí Agendar


ETAPA 14: DEPLOY MVP üöÄ
Objetivo: Colocar no ar
14.1. Dockerfile (Pr√°tica)
14.2. CI/CD (GitHub Actions) (Pr√°tica)
14.3. Deploy (Railway/Render) (Pr√°tica)